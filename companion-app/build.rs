use std::{
    fs::{self, File},
    io::Write,
    path::Path,
};

fn main() {
    println!("cargo:rerun-if-changed=assets/icons");

    generate_icon_include_method();

    // TODO: maybe copy assets/resources folder into target folder after build?
    // but maybe it's also better to put that into a CI pipeline
}

fn generate_icon_include_method() {
    let icon_dir = Path::new("assets/icons");
    let mut entries = fs::read_dir(icon_dir)
        .expect("failed to read assets/icons")
        .filter_map(Result::ok)
        // only png files
        .filter(|e| e.path().extension().and_then(|s| s.to_str()) == Some("png"))
        .collect::<Vec<_>>();

    entries.sort_by_key(|e| e.file_name());

    // 4) Prepare contents of the generated file:
    let mut generated = String::new();
    generated.push_str("////////////////////////////////////////////////////////////\n");
    generated.push_str("/////// Auto-generated by build.rs â€” DO NOT EDIT  //////////\n");
    generated.push_str("////////////////////////////////////////////////////////////\n\n");
    generated.push_str("use std::collections::HashMap;\n");
    generated.push_str("use egui::{ImageSource, include_image};\n\n");
    generated.push_str("pub fn get_icon_map() -> HashMap<String, ImageSource<'static>> {\n");
    generated.push_str("    let mut m = HashMap::new();\n");

    for entry in &entries {
        let file_name = entry.file_name().to_string_lossy().into_owned();
        // strip ".png" to get "type_fire"
        let key = file_name.strip_suffix(".png").unwrap().to_lowercase();
        let literal_path = entry.path(); // e.g. "assets/icons/type_fire.png"

        generated.push_str("\n    m.insert(");
        generated.push_str(&format!("\n        \"{key}\".to_owned(),"));
        generated.push_str(&format!(
            "\n        include_image!(\"../../{}\"),",
            literal_path.display().to_string().replace("\\", "/")
        ));
        generated.push_str("\n    );");
        // generated.push_str(&format!(
        //     "    m.insert(\n        \"{key}\".to_owned(),\n        {{\n            let bytes = include_bytes!(\"{path}\");\n            egui_extras::load_image_bytes(bytes)\n                .expect(\"failed to decode {file_name}\")\n        }},\n    );\n",
        //     key = key,
        //     path = literal_path.display(),
        //     file_name = file_name,
        // ));
    }

    generated.push_str("\n    m\n}\n");

    // TODO: only write file, if it actually changed to avoid forced cargo rebuild everytime
    // INFO: it's a bit odd to generate into the src folder, but I think it's the right choice here
    let out_dir = "src/frontend";
    // let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let dest_path = Path::new(&out_dir).join("gen_icon_includes.rs");
    let mut f = File::create(&dest_path).expect("could not create gen_icon_includes.rs");
    f.write_all(generated.as_bytes())
        .expect("failed to write gen_icon_includes.rs");
}
